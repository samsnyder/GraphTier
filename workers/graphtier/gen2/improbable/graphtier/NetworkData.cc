// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/graphtier/NetworkData.schema
#include <improbable/graphtier/NetworkData.h>
#include <improbable/entity_state.pb.h>
#include <improbable/graphtier/NetworkData.pb.h>

namespace improbable {
namespace graphtier {

// Implementation of ExitNodeSet.
//----------------------------------------------------------------

ExitNodeSet::ExitNodeSet(
    const ::worker::List< ::worker::EntityId >& exit_nodes,
    ::worker::EntityId network_id)
: _exit_nodes{exit_nodes}
, _network_id{network_id} {}

bool ExitNodeSet::operator==(const ExitNodeSet& value) const {
  return
      _exit_nodes == value._exit_nodes &&
      _network_id == value._network_id;
}

bool ExitNodeSet::operator!=(const ExitNodeSet& value) const {
  return !operator==(value);
}

const ::worker::List< ::worker::EntityId >& ExitNodeSet::exit_nodes() const {
  return _exit_nodes;
}

::worker::List< ::worker::EntityId >& ExitNodeSet::exit_nodes() {
  return _exit_nodes;
}

ExitNodeSet& ExitNodeSet::set_exit_nodes(const ::worker::List< ::worker::EntityId >& value) {
  _exit_nodes = value;
  return *this;
}

::worker::EntityId ExitNodeSet::network_id() const {
  return _network_id;
}

::worker::EntityId& ExitNodeSet::network_id() {
  return _network_id;
}

ExitNodeSet& ExitNodeSet::set_network_id(::worker::EntityId value) {
  _network_id = value;
  return *this;
}

// Implementation of NetworkDataData.
//----------------------------------------------------------------

NetworkDataData::NetworkDataData(
    std::uint32_t level,
    const ::worker::List< ::worker::EntityId >& nodes,
    const ::worker::List< ::improbable::graphtier::ExitNodeSet >& exit_node_sets)
: _level{level}
, _nodes{nodes}
, _exit_node_sets{exit_node_sets} {}

bool NetworkDataData::operator==(const NetworkDataData& value) const {
  return
      _level == value._level &&
      _nodes == value._nodes &&
      _exit_node_sets == value._exit_node_sets;
}

bool NetworkDataData::operator!=(const NetworkDataData& value) const {
  return !operator==(value);
}

std::uint32_t NetworkDataData::level() const {
  return _level;
}

std::uint32_t& NetworkDataData::level() {
  return _level;
}

NetworkDataData& NetworkDataData::set_level(std::uint32_t value) {
  _level = value;
  return *this;
}

const ::worker::List< ::worker::EntityId >& NetworkDataData::nodes() const {
  return _nodes;
}

::worker::List< ::worker::EntityId >& NetworkDataData::nodes() {
  return _nodes;
}

NetworkDataData& NetworkDataData::set_nodes(const ::worker::List< ::worker::EntityId >& value) {
  _nodes = value;
  return *this;
}

const ::worker::List< ::improbable::graphtier::ExitNodeSet >& NetworkDataData::exit_node_sets() const {
  return _exit_node_sets;
}

::worker::List< ::improbable::graphtier::ExitNodeSet >& NetworkDataData::exit_node_sets() {
  return _exit_node_sets;
}

NetworkDataData& NetworkDataData::set_exit_node_sets(const ::worker::List< ::improbable::graphtier::ExitNodeSet >& value) {
  _exit_node_sets = value;
  return *this;
}

// Implementation of NetworkData.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId NetworkData::ComponentId;

bool NetworkData::Update::operator==(const NetworkData::Update& value) const {
  return
      _level == value._level &&
      _nodes == value._nodes &&
      _exit_node_sets == value._exit_node_sets;
}

bool NetworkData::Update::operator!=(const NetworkData::Update& value) const {
  return !operator==(value);
}

NetworkData::Update NetworkData::Update::FromInitialData(const ::improbable::graphtier::NetworkDataData& data) {
  NetworkData::Update update;
  update._level.emplace(data.level());
  update._nodes.emplace(data.nodes());
  update._exit_node_sets.emplace(data.exit_node_sets());
  return update;
}

::improbable::graphtier::NetworkDataData NetworkData::Update::ToInitialData() const {
  return ::improbable::graphtier::NetworkDataData(
      *_level,
      *_nodes,
      *_exit_node_sets);
}

void NetworkData::Update::ApplyTo(::improbable::graphtier::NetworkDataData& data) const {
  if (_level) {
    data.set_level(*_level);
  }
  if (_nodes) {
    data.set_nodes(*_nodes);
  }
  if (_exit_node_sets) {
    data.set_exit_node_sets(*_exit_node_sets);
  }
}

const ::worker::Option< std::uint32_t >& NetworkData::Update::level() const {
  return _level;
}

::worker::Option< std::uint32_t >& NetworkData::Update::level() {
  return _level;
}

NetworkData::Update& NetworkData::Update::set_level(std::uint32_t value) {
  _level.emplace(value); return *this;
}

const ::worker::Option< ::worker::List< ::worker::EntityId > >& NetworkData::Update::nodes() const {
  return _nodes;
}

::worker::Option< ::worker::List< ::worker::EntityId > >& NetworkData::Update::nodes() {
  return _nodes;
}

NetworkData::Update& NetworkData::Update::set_nodes(const ::worker::List< ::worker::EntityId >& value) {
  _nodes.emplace(value); return *this;
}

const ::worker::Option< ::worker::List< ::improbable::graphtier::ExitNodeSet > >& NetworkData::Update::exit_node_sets() const {
  return _exit_node_sets;
}

::worker::Option< ::worker::List< ::improbable::graphtier::ExitNodeSet > >& NetworkData::Update::exit_node_sets() {
  return _exit_node_sets;
}

NetworkData::Update& NetworkData::Update::set_exit_node_sets(const ::worker::List< ::improbable::graphtier::ExitNodeSet >& value) {
  _exit_node_sets.emplace(value); return *this;
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Serialize_ExitNodeSet(
    const ::improbable::graphtier::ExitNodeSet& data,
    ::schema::improbable::graphtier::ExitNodeSet& proto) {
  for (const auto& item : data.exit_nodes()) {
    proto.add_field1_exit_nodes(item);
  }
  proto.set_field2_network_id(data.network_id());
}

::improbable::graphtier::ExitNodeSet Deserialize_ExitNodeSet(
    const ::schema::improbable::graphtier::ExitNodeSet& proto) {
  ::improbable::graphtier::ExitNodeSet result{
      {},
      proto.field2_network_id()};
  for (const auto& item : proto.field1_exit_nodes()) {
    result.exit_nodes().emplace_back(item);
  }
  return result;
}

void Serialize_NetworkDataData(
    const ::improbable::graphtier::NetworkDataData& data,
    ::schema::improbable::graphtier::NetworkDataData& proto) {
  proto.set_field1_level(data.level());
  for (const auto& item : data.nodes()) {
    proto.add_field2_nodes(item);
  }
  for (const auto& item : data.exit_node_sets()) {
    ::improbable::graphtier::detail::Serialize_ExitNodeSet(item, *proto.add_field3_exit_node_sets());
  }
}

::improbable::graphtier::NetworkDataData Deserialize_NetworkDataData(
    const ::schema::improbable::graphtier::NetworkDataData& proto) {
  ::improbable::graphtier::NetworkDataData result{
      proto.field1_level(),
      {},
      {}};
  for (const auto& item : proto.field2_nodes()) {
    result.nodes().emplace_back(item);
  }
  for (const auto& item : proto.field3_exit_node_sets()) {
    result.exit_node_sets().emplace_back(::improbable::graphtier::detail::Deserialize_ExitNodeSet(item));
  }
  return result;
}

namespace {

void VtableBufferFree_NetworkData(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_NetworkData(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::improbable::graphtier::NetworkData::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::graphtier::NetworkDataData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_NetworkData* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_NetworkData(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_NetworkData(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    ::schema::improbable::EntityComponentUpdate proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    *object = new ::improbable::graphtier::NetworkData::Update;
    auto client_object = static_cast< ::improbable::graphtier::NetworkData::Update* >(*object);
    {
      const auto& proto = proto_wrapper.entity_state().GetExtension(::schema::improbable::graphtier::NetworkData::component_extension);

      std::set<std::uint32_t> fields_to_clear{proto_wrapper.fields_to_clear().begin(),
                                              proto_wrapper.fields_to_clear().end()};
      if (proto.has_field1_level()) {
        client_object->level().emplace(proto.field1_level());
      }
      if (!proto.field2_nodes().empty() || fields_to_clear.count(2)) {
        client_object->nodes().emplace();
        for (const auto& item : proto.field2_nodes()) {
          client_object->nodes()->emplace_back(item);
        }
      }
      if (!proto.field3_exit_node_sets().empty() || fields_to_clear.count(3)) {
        client_object->exit_node_sets().emplace();
        for (const auto& item : proto.field3_exit_node_sets()) {
          client_object->exit_node_sets()->emplace_back(::improbable::graphtier::detail::Deserialize_ExitNodeSet(item));
        }
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::schema::improbable::EntityState proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    const auto& proto = proto_wrapper.GetExtension(::schema::improbable::graphtier::NetworkData::component_extension);

    *object = new ::improbable::graphtier::NetworkDataData{::improbable::graphtier::detail::Deserialize_NetworkDataData(proto)};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::schema::improbable::EntityCommand proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::schema::improbable::EntityCommand proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
  }
  return true;
}

void VtableSerialize_NetworkData(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    ::schema::improbable::EntityComponentUpdate proto_wrapper;
    const auto& data = *static_cast<const ::improbable::graphtier::NetworkData::Update*>(object);
    {
      auto& proto = *proto_wrapper.mutable_entity_state()->MutableExtension(::schema::improbable::graphtier::NetworkData::component_extension);
      if (data.level()) {
        proto.set_field1_level(*data.level());
      }
      if (data.nodes()) {
        if (data.nodes()->empty()) {
          proto_wrapper.add_fields_to_clear(2);
        }
        for (const auto& item : *data.nodes()) {
          proto.add_field2_nodes(item);
        }
      }
      if (data.exit_node_sets()) {
        if (data.exit_node_sets()->empty()) {
          proto_wrapper.add_fields_to_clear(3);
        }
        for (const auto& item : *data.exit_node_sets()) {
          ::improbable::graphtier::detail::Serialize_ExitNodeSet(item, *proto.add_field3_exit_node_sets());
        }
      }
    }
    {
    }

    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::schema::improbable::EntityState proto_wrapper;
    const auto& data = *static_cast<const ::improbable::graphtier::NetworkDataData*>(object);
    auto& proto = *proto_wrapper.MutableExtension(::schema::improbable::graphtier::NetworkData::component_extension);

    ::improbable::graphtier::detail::Serialize_NetworkDataData(data, proto);
    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::schema::improbable::EntityCommand proto_wrapper;
    proto_wrapper.MutableExtension(::schema::improbable::graphtier::NetworkData::command_extension);


    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::schema::improbable::EntityCommand proto_wrapper;
    proto_wrapper.MutableExtension(::schema::improbable::graphtier::NetworkData::command_extension);


    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  }
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_NetworkData() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      8002,
      &detail::VtableBufferFree_NetworkData,
      &detail::VtableFree_NetworkData,
      &detail::VtableCopy_NetworkData,
      &detail::VtableDeserialize_NetworkData,
      &detail::VtableSerialize_NetworkData,
  };
  return vtable;
}

}  // ::detail

}  // ::graphtier
}  // ::improbable
