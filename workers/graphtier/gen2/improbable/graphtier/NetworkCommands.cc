// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/graphtier/NetworkCommands.schema
#include <improbable/graphtier/NetworkCommands.h>
#include <improbable/entity_state.pb.h>
#include <improbable/graphtier/NetworkCommands.pb.h>

namespace improbable {
namespace graphtier {

// Implementation of NetworkCommandsData.
//----------------------------------------------------------------

NetworkCommandsData::NetworkCommandsData() {}

bool NetworkCommandsData::operator==(const NetworkCommandsData&) const {
  return true;
}

bool NetworkCommandsData::operator!=(const NetworkCommandsData& value) const {
  return !operator==(value);
}

// Implementation of NodeToNodeRequest.
//----------------------------------------------------------------

NodeToNodeRequest::NodeToNodeRequest(
    ::worker::EntityId from,
    ::worker::EntityId to)
: _from{from}
, _to{to} {}

bool NodeToNodeRequest::operator==(const NodeToNodeRequest& value) const {
  return
      _from == value._from &&
      _to == value._to;
}

bool NodeToNodeRequest::operator!=(const NodeToNodeRequest& value) const {
  return !operator==(value);
}

::worker::EntityId NodeToNodeRequest::from() const {
  return _from;
}

::worker::EntityId& NodeToNodeRequest::from() {
  return _from;
}

NodeToNodeRequest& NodeToNodeRequest::set_from(::worker::EntityId value) {
  _from = value;
  return *this;
}

::worker::EntityId NodeToNodeRequest::to() const {
  return _to;
}

::worker::EntityId& NodeToNodeRequest::to() {
  return _to;
}

NodeToNodeRequest& NodeToNodeRequest::set_to(::worker::EntityId value) {
  _to = value;
  return *this;
}

// Implementation of NodeToNodeResponse.
//----------------------------------------------------------------

NodeToNodeResponse::NodeToNodeResponse(const ::improbable::graphtier::Path& path)
: _path{path} {}

bool NodeToNodeResponse::operator==(const NodeToNodeResponse& value) const {
  return
      _path == value._path;
}

bool NodeToNodeResponse::operator!=(const NodeToNodeResponse& value) const {
  return !operator==(value);
}

const ::improbable::graphtier::Path& NodeToNodeResponse::path() const {
  return _path;
}

::improbable::graphtier::Path& NodeToNodeResponse::path() {
  return _path;
}

NodeToNodeResponse& NodeToNodeResponse::set_path(const ::improbable::graphtier::Path& value) {
  _path = value;
  return *this;
}

// Implementation of NetworkCommands.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId NetworkCommands::ComponentId;

constexpr const std::uint32_t NetworkCommands::Commands::NodeToNode::CommandId;

bool NetworkCommands::Update::operator==(const NetworkCommands::Update&) const {
  return true;
}

bool NetworkCommands::Update::operator!=(const NetworkCommands::Update& value) const {
  return !operator==(value);
}

NetworkCommands::Update NetworkCommands::Update::FromInitialData(const ::improbable::graphtier::NetworkCommandsData&) {
  return NetworkCommands::Update{};
}

::improbable::graphtier::NetworkCommandsData NetworkCommands::Update::ToInitialData() const {
  return ::improbable::graphtier::NetworkCommandsData();
}

void NetworkCommands::Update::ApplyTo(::improbable::graphtier::NetworkCommandsData&) const {
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Serialize_NetworkCommandsData(
    const ::improbable::graphtier::NetworkCommandsData&,
    ::schema::improbable::graphtier::NetworkCommandsData&) {}

::improbable::graphtier::NetworkCommandsData Deserialize_NetworkCommandsData(
    const ::schema::improbable::graphtier::NetworkCommandsData&) {
  return {};
}

void Serialize_NodeToNodeRequest(
    const ::improbable::graphtier::NodeToNodeRequest& data,
    ::schema::improbable::graphtier::NodeToNodeRequest& proto) {
  proto.set_field1_from(data.from());
  proto.set_field2_to(data.to());
}

::improbable::graphtier::NodeToNodeRequest Deserialize_NodeToNodeRequest(
    const ::schema::improbable::graphtier::NodeToNodeRequest& proto) {
  ::improbable::graphtier::NodeToNodeRequest result{
      proto.field1_from(),
      proto.field2_to()};
  return result;
}

void Serialize_NodeToNodeResponse(
    const ::improbable::graphtier::NodeToNodeResponse& data,
    ::schema::improbable::graphtier::NodeToNodeResponse& proto) {
  ::improbable::graphtier::detail::Serialize_Path(data.path(), *proto.mutable_field1_path());
}

::improbable::graphtier::NodeToNodeResponse Deserialize_NodeToNodeResponse(
    const ::schema::improbable::graphtier::NodeToNodeResponse& proto) {
  ::improbable::graphtier::NodeToNodeResponse result{
      ::improbable::graphtier::detail::Deserialize_Path(proto.field1_path())};
  return result;
}

namespace {

void VtableBufferFree_NetworkCommands(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_NetworkCommands(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    delete static_cast< ::improbable::graphtier::NetworkCommands::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::graphtier::NetworkCommandsData* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_NetworkCommands* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_NetworkCommands(
    ::worker::ComponentId, std::uint8_t, ::worker::detail::ClientObject* object) {
  return object;
}

std::uint8_t VtableDeserialize_NetworkCommands(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    ::schema::improbable::EntityComponentUpdate proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    *object = new ::improbable::graphtier::NetworkCommands::Update;
    {
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::schema::improbable::EntityState proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    const auto& proto = proto_wrapper.GetExtension(::schema::improbable::graphtier::NetworkCommands::component_extension);

    *object = new ::improbable::graphtier::NetworkCommandsData{::improbable::graphtier::detail::Deserialize_NetworkCommandsData(proto)};
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::schema::improbable::EntityCommand proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    const auto& proto = proto_wrapper.GetExtension(::schema::improbable::graphtier::NetworkCommands::command_extension);

    if (proto.has_command_node_to_node_request()) {
      *object = new detail::GenericCommandObject_NetworkCommands{
          ::improbable::graphtier::NetworkCommands::Commands::NodeToNode::CommandId,
         ::improbable::graphtier::detail::Deserialize_NodeToNodeRequest(proto.command_node_to_node_request())};
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::schema::improbable::EntityCommand proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    const auto& proto = proto_wrapper.GetExtension(::schema::improbable::graphtier::NetworkCommands::command_extension);

    if (proto.has_command_node_to_node_response()) {
      *object = new detail::GenericCommandObject_NetworkCommands{
          ::improbable::graphtier::NetworkCommands::Commands::NodeToNode::CommandId,
          ::improbable::graphtier::detail::Deserialize_NodeToNodeResponse(proto.command_node_to_node_response())};
    }
  }
  return true;
}

void VtableSerialize_NetworkCommands(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    ::schema::improbable::EntityComponentUpdate proto_wrapper;
    {
      proto_wrapper.mutable_entity_state()->MutableExtension(::schema::improbable::graphtier::NetworkCommands::component_extension);
    }
    {
    }

    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::schema::improbable::EntityState proto_wrapper;
    const auto& data = *static_cast<const ::improbable::graphtier::NetworkCommandsData*>(object);
    auto& proto = *proto_wrapper.MutableExtension(::schema::improbable::graphtier::NetworkCommands::component_extension);

    ::improbable::graphtier::detail::Serialize_NetworkCommandsData(data, proto);
    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::schema::improbable::EntityCommand proto_wrapper;
    const auto& data = *static_cast<const GenericCommandObject_NetworkCommands*>(object);
    auto& proto = *proto_wrapper.MutableExtension(::schema::improbable::graphtier::NetworkCommands::command_extension);

    if (data.CommandId == ::improbable::graphtier::NetworkCommands::Commands::NodeToNode::CommandId) {
      ::improbable::graphtier::detail::Serialize_NodeToNodeRequest(*data.CommandObject.data< ::improbable::graphtier::NodeToNodeRequest >(), *proto.mutable_command_node_to_node_request());
    }

    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::schema::improbable::EntityCommand proto_wrapper;
    const auto& data = *static_cast<const GenericCommandObject_NetworkCommands*>(object);
    auto& proto = *proto_wrapper.MutableExtension(::schema::improbable::graphtier::NetworkCommands::command_extension);

    if (data.CommandId == ::improbable::graphtier::NetworkCommands::Commands::NodeToNode::CommandId) {
      ::improbable::graphtier::detail::Serialize_NodeToNodeResponse(*data.CommandObject.data< ::improbable::graphtier::NodeToNodeResponse >(), *proto.mutable_command_node_to_node_response());
    }

    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  }
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_NetworkCommands() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      8001,
      &detail::VtableBufferFree_NetworkCommands,
      &detail::VtableFree_NetworkCommands,
      &detail::VtableCopy_NetworkCommands,
      &detail::VtableDeserialize_NetworkCommands,
      &detail::VtableSerialize_NetworkCommands,
  };
  return vtable;
}

}  // ::detail

}  // ::graphtier
}  // ::improbable
